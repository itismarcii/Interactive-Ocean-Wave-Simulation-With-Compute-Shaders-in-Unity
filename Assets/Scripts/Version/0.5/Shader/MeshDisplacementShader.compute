#pragma kernel wave_displacement 0
#pragma kernel triangle_setup 1

#define PI 3.14159265358979323846 
#define GRAVITY 9.81

#define THREAD_GROUP_SIZE_X 32
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 32

struct WaveParameter
{
    float2 direction;
    float amplitude;
    float wave_length;
    float speedModifer;
};

// Input
RWStructuredBuffer<WaveParameter> WaveParameters;

// Output
RWStructuredBuffer<float3> VerticesOutput;
RWStructuredBuffer<int> TriangleOutput;

Texture2D gaussianNoise;

int mesh_resolution = 1;
float _TIME_;
float scaling;
float2 meshShift;
float meshCenter;

int wave_parameter_count;
float max_height_amplifier;

float3 gerstner_wave_displacement(const float3 position, WaveParameter wave)
{
    const float maxHeight = (wave.wave_length / 7) + max_height_amplifier;                  // Clamped max Height
    const float k = 2 * PI / wave.wave_length;                                              // Wave Number
    const float A = wave.amplitude * 2 > maxHeight ? maxHeight / 2 : wave.amplitude;        // Amplitude
    // const float A = wave.amplitude;                                                      // Amplitude
    const float c = sqrt(PI / k);                                                           // Wave Speed
    const float2 direction = normalize(wave.direction);                                     // Normalized Wave Direction
    
    const float f = k * dot(direction, position.xz) - (c * _TIME_) * wave.speedModifer;     // Wave Phase
    
    return float3(                                                                          // Displacement
        A * direction.x * cos(f),
        A * sin(f),
        A * direction.y * cos(f));


    // float k = TWOPI / 100;
    // float2 direction = normalize(wave.direction);
    // float wave_length = wave.speedModifer / sqrt(GRAVITY * TWOPI);
    // float frequency = TWOPI / wave_length;
    // float phase = dot(position, direction) * frequency + _TIME_ * frequency;
    // float steepness = 0.8f / (wave_length * wave.amplitude * 4);
    // float amplitude = wave.amplitude * steepness;
    // float cosine = cos(phase);
    // float sine = sin(phase);
    // float2 dispacement = amplitude * direction * cosine;
    // float2 gradient = amplitude * direction * sine * k;
    // float laplacian = -amplitude * dot(direction, direction) * k * k * cosine;
    // float result = dot(dispacement, position) + laplacian;
}

float3 fft_calculation(const float3 position, const WaveParameter wave, const float noise)
{
    const float2 wind_direction = wave.direction;
    const float wind_speed = wave.speedModifer;
    const float wave_amplitude = wave.amplitude * 10;

    const float frequency = 2 * PI / wave.wave_length;
    const float2 wave_vector = frequency * wind_direction;

    const float phase_shift = dot(wave_vector, position.xz);
    const float wave_height = wave_amplitude * noise * sin(phase_shift - wind_speed * _TIME_);
    
    return float3(position.x, wave_height, position.z);
}

float3 displacement_calculation(const float3 position, const float noise)
{
    float3 displacement = float3(0,0,0);

    // displacement += fft_calculation(position, WaveParameters[0], noise);
    
    // for (int i = 0; i < wave_parameter_count; i++)
    //     displacement += gerstner_wave_displacement(position, WaveParameters[i]);

    for (int i = 0; i < wave_parameter_count; i++)
    {
        displacement += fft_calculation(position, WaveParameters[i], noise);
    }
        
    return displacement;
}

[numthreads(32,1,32)]
void wave_displacement (int3 id : SV_DispatchThreadID)
{
    // Skip iterations if the thread ID is invalid
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    const int vertexCount = mesh_resolution * mesh_resolution;
    const int chunkResolution = mesh_resolution >> 1 < 1 ? 1 : mesh_resolution >> 1;
    
    for(int x = 0; x < chunkResolution; x++)
    {
        for(int z = 0; z < chunkResolution; z++)
        {
            float3 pos = id;
            pos.x += x * 32;
            pos.z += z * 32;

            if(pos.x >= mesh_resolution || pos.z >= mesh_resolution) continue;;

            const int index = pos.x + pos.z * mesh_resolution;

            if(index > vertexCount) continue;
            
            pos.xz *= scaling;
            pos.xz += meshShift.xy;
            float4 noise = gaussianNoise.Load(int3(pos.xz, 0));
            pos.xz -= meshCenter;

            pos += displacement_calculation(pos, noise.y);

            pos.xz -= meshShift.xy;

            VerticesOutput[index] = pos;
        }
    }
}

[numthreads(32,1,32)]
void triangle_setup (int3 id : SV_DispatchThreadID)
{
    // Skip iterations if the thread ID is invalid
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    const int chunkResolution = mesh_resolution >> 1 < 1 ? 1 : mesh_resolution >> 1;
    
    for(int x = 0; x < chunkResolution; x++)
    {
        for(int z = 0; z < chunkResolution; z++)
        {
            float3 position = id;
            position.x += x * 32;
            position.z += z * 32;

            if(position.x >= mesh_resolution - 1 || position.z >= mesh_resolution - 1) continue;;
            
            int index = (position.x + (mesh_resolution - 1) * position.z) * 6;
            
            TriangleOutput[index++] = position.x + mesh_resolution * position.z;
            TriangleOutput[index++] = position.x + mesh_resolution * (position.z + 1);
            TriangleOutput[index++] = (position.x + 1) + mesh_resolution * (position.z + 1);

            TriangleOutput[index++] = (position.x + 1) + mesh_resolution * (position.z + 1);
            TriangleOutput[index++] = (position.x + 1) + mesh_resolution * position.z;
            TriangleOutput[index] = position.x + mesh_resolution * position.z;
        }
    }
}
