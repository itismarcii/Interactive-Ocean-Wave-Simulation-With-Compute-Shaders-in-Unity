#pragma kernel wave_displacement 0
#pragma kernel triangle_setup 1

#define PI 3.14159265358979323846

#define THREAD_GROUP_SIZE_X 32
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 32

struct WaveParameter
{
    float2 direction;
    float amplitude;
    float wave_length;
    float speedModifer;
};

// Input
RWStructuredBuffer<WaveParameter> WaveParameters;

// Output
RWStructuredBuffer<float3> VerticesOutput;
RWStructuredBuffer<float2> UvOutput;
RWStructuredBuffer<int> TriangleOutput;


int mesh_resolution = 1;
float _TIME_;
float scaling;
float2 meshShift;
float meshCenter;

int wave_parameter_count;
float max_height_amplifier;

float3 gerstner_wave_displacement(const float3 position, WaveParameter wave)
{
    const float maxHeight = (wave.wave_length / 7) + max_height_amplifier;                  // Clamped max Height
    const float k = 2 * PI / wave.wave_length;                                              // Wave Number
    const float A = wave.amplitude * 2 > maxHeight ? maxHeight / 2 : wave.amplitude;        // Amplitude
    const float c = sqrt(PI / k);                                                           // Wave Speed
    const float2 direction = normalize(wave.direction);                                     // Normalized Wave Direction
    const float f = k * dot(direction, position.xz) - (c * _TIME_) * wave.speedModifer;     // Wave Phase

    return float3(                                                                          // Displacement
        A * direction.x * cos(f),
        A * sin(f),
        A * direction.y * cos(f));
}

float3 displacement_calculation(const float3 position)
{
    float3 displacement = float3(0,0,0);
    
    for (int i = 0; i < wave_parameter_count; i++)
         displacement += gerstner_wave_displacement(position, WaveParameters[i]);
    
    return displacement;
}

[numthreads(32,1,32)]
void wave_displacement (int3 id : SV_DispatchThreadID)
{
    // Skip iterations if the thread ID is invalid
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    const int vertexCount = mesh_resolution * mesh_resolution;
    const int chunkResolution = mesh_resolution >> 1 < 1 ? 1 : mesh_resolution >> 1;
    
    for(int x = 0; x < chunkResolution; x++)
    {
        for(int z = 0; z < chunkResolution; z++)
        {
            float3 pos = id;
            pos.x += x * 32;
            pos.z += z * 32;

            if(pos.x >= mesh_resolution || pos.z >= mesh_resolution) continue;;

            const int index = pos.x + pos.z * mesh_resolution;

            if(index > vertexCount) continue;

            pos.xz *= scaling;
            pos.xz -= meshCenter;
            pos.xz += meshShift.xy;
            
            pos += displacement_calculation(pos);
            pos.xz -= meshShift.xy;

            VerticesOutput[index] = pos;
            UvOutput[index] = pos.xz;
        }
    }
}

[numthreads(32,1,32)]
void triangle_setup (int3 id : SV_DispatchThreadID)
{
    // Skip iterations if the thread ID is invalid
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    const int chunkResolution = mesh_resolution >> 1 < 1 ? 1 : mesh_resolution >> 1;
    
    for(int x = 0; x < chunkResolution; x++)
    {
        for(int z = 0; z < chunkResolution; z++)
        {
            float3 position = id;
            position.x += x * 32;
            position.z += z * 32;

            if(position.x >= mesh_resolution - 1 || position.z >= mesh_resolution - 1) continue;;
            
            int index = (position.x + (mesh_resolution - 1) * position.z) * 6;
            
            TriangleOutput[index++] = position.x + mesh_resolution * position.z;
            TriangleOutput[index++] = position.x + mesh_resolution * (position.z + 1);
            TriangleOutput[index++] = (position.x + 1) + mesh_resolution * (position.z + 1);

            TriangleOutput[index++] = (position.x + 1) + mesh_resolution * (position.z + 1);
            TriangleOutput[index++] = (position.x + 1) + mesh_resolution * position.z;
            TriangleOutput[index] = position.x + mesh_resolution * position.z;
        }
    }
}
